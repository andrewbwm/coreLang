#id: "org.mal-lang.coreLang"
#version: "0.0.1"

include "coreVulnerability.mal"
include "VulnerabilityManual.mal"
include "VulnerabilityAutomatic.mal"

category System {

    abstract asset Object
    {
      & specificAccess

      & fullAccess

      | useVulnerability
        ->  vulnerabilities.abuse
    }

    abstract asset System extends Object {
      | connect
        user info: "The attacker can connect to the instance, e.g., through a shell, but has not yet authenticated."
        ->  fullAccess,
            specificAccess

      | allPrivilegeAuthenticate @hidden
        ->  fullAccess // This will provide access on all privileges connected with the system

      | individualPrivilegeAuthenticate @hidden
        ->  specificAccess

      & fullAccess
        ->  highPrivAssignedIds.assume,
            lowPrivAssignedIds,assume

      & specificAccess
        ->  sysExecutedApps.localConnect // I do not know what more we need here...
    }

    //asset OperatingSystem extends Application{
      // If the OS is compromised (at kernel level for example, or admin rights) then all the executed applications should be compromised
      // If AD is used then having full access on the OS should lead to possible compromise of any associated Identity (Per)
    //}

    asset Application extends Object{

      | localConnect
        user info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally interact with the application."
        ->  localAccess,
            extensionPoint.incoming // Connection to all possible vulnerabilities that might be connected to the Application

      | networkRequestConnect
        user info: "The attacker has successfully sent a request to the application."
        -> networkAccess//,
           // Tracebility step for security groups. Callback to all security groups with inbound rules associated with the application's port
           //(networkInterfaces.securityGroups.containedRules[InboundSecurityGroupRule] /\ portRanges.superPortRanges*.securityGroupRules[InboundSecurityGroupRule]).containingGroup.calledByApplication

      | networkRespondConnect [Exponential(0.001)]
        user info: "An attacker may be able to respond to requests submitted by an application."

      | authenticate
        user info: "The attacker is able to authenticate with the appropriate credentials."
        ->  localAccess,
            networkAccess

      & localAccess @hidden
        ->  access

      & networkAccess @hidden
        ->  access

      | access
        user info: "Legitimate access, as user or as administrator."
        ->  read,
            modify,
            deny,
            // shellInstance.connect
            appExecutedApps.access // Gain access on all applications executed by this (host) application

      | codeExecution
        user info: "Vulnerabilities in the application could allow an attacker to inject code into the service process, thus assuming the service's privileges on the hosting instance. An attacker could under these circumstances influence other applications or the underlying operating system itself."
        developer info: "This attack steps specifically models the type of code injections which result in arbitrary code executions (e.g., buffer overflows), where the attacker can redirect the flow of execution, for example, by modifying program counter/instruction pointer of the host. (See CWE-94 on code injection <https://cwe.mitre.org/data/definitions/94.html> and, for example, CAPEC-100 on overflowing buffers <https://capec.mitre.org/data/definitions/100.html>)"
        ->  access,
            // nonShellInstance.connect,
            executionPrivileges.assume

      | read
        user info: "The attacker can read some or all of this service's code and data."
        developer info: "We don't model the services data, as we do not expect that information will be available to the parser. We also don't differentiate between service administrators and service users (e.g., mail service admins and users), as we have no information about the services."

      | modify
        user info: "The attacker can modify some or all of this service's data."

      | deny
        user info: "The attacker can deny some or all functionality and data pertaining to this service."

    }
}

category Communication {

    // Datastore is mainly used for pointing out where a piece of precious data is hosted. 
    // Good as is today except that a Datastore object should also be associated with an AccessLevel object which you need to "unlock" before you can access that data.
    asset DataStore extends Object {
      | authenticatedAccess
        ->  datas.access
    }

    asset Data {
        & access
          ->  read,
              write,
              delete

        | read {C}
          user info: "The attacker can read the data."
          ->  containedData.read

        | write {I}
          user info: "The attacker can write to the location of the data, effectively deleting it."
          ->  containedData.write,
              delete

        | delete {I,A}
          user info: "The attacker can delete the data."
          ->  containedData.delete
    }
}

category Security {

    asset Identity 
    {
        | assume
          user info: "After authentication or compromise of an account/identity, assume its privileges. This is both legitimate and illegitimate access!"
          ->  lowPrivManagedSystems.individualPrivilegeAuthenticate,
              highPrivManagedSystems.allPrivilegeAuthenticate,
              lowPrivilegeApplications.authenticate,
              highPrivilegeApplications.authenticate,
              readPrivData.read,
              writePrivData.write,
              deletePrivData.delete,
              accessPrivDatastore.authenticatedAccess
    }

    asset Credentials
    {
      | use
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  identities.assume

      | attemptAccess
        user info: "The attacker is attempting to access the credentials."
        -> credentialTheft

      | credentialTheft [Exponential(0.001)]
        user info: "The attacker is able to steal the credentials."
        -> identities.assume
    }
}

category User {

    asset User 
    {
        | compromise // This should be renamed
                ->  userIds.assume
    }
}

category Networking {
    // If you have access to a network zone, you shall be able to connect (not log in) to any other service on the same network. (nmap scan) (Joar)
    // If you have managed to log in to and use a proxy, transparent or not, you shall be able to access any service protected by that proxy. (Joar)

    asset Network extends Object {
    }

    asset Firewall extends System {
      | forwarding

      | dos
        // This will cascade the DoS attack on the connected networks and connected connections

    }

    asset Connection extends Object {
    }

    abstract asset Proxy extends Object {
    }

    asset IPS extends Proxy {
    }

    asset IDS extends Proxy {
    }
}

associations {
	System           [hostSystem]           1 <-- SysExecution          --> *   [sysExecutedApps]        Application
  Application      [hostApp]              1 <-- AppExecution          --> *   [appExecutedApps]        Application
      developer info: "Application 1 runs application 2 runs application 3! (Where application 1 can be an OS, application 2 is a VM and application 3 is app running on the VM."
  //OperatingSystem  [os]                 1 <-- AppExecution          --> *   [applications]           Application
  // Idea: allow applications to run other applications. Cons: confusing for users, too complex. Pros: Higher flexibility. Verdict: remove OS asset
	Network          [networks]             * <-- NetworkExposure       --> *   [systems]                System
  Application      [netclients]           * <-- ApplicationConnection --> 1   [netapplication]         Application //This is a dataflow... If any side of the connection is compromised -> other side can be compromised (e.g client side attack)
  Application      [application]          * <-- ApplicationConnection --> 1   [connection]             Connection //The connection asset is just the dataflow renamed
  Network          [network]              * <-- NetworkConnection     --> *   [systems]                Connection
	Connection       [connection]           1 <-- DataInTransit         --> *   [data]                   Data 
	Firewall         [firewall]             1 <-- Bridges               --> *   [networks]               Network
  // We need to talk about those two:
  Proxy            [proxy]                1 <-- ProxyConnection       --> *   [networks]               Network
  Proxy            [proxy]                1 <-- RelationTo            --> 1   [firewall]               Firewall
  // Data related associations
	DataStore        [datastore]            1 <-- DataStoring           --> *   [datas]                  Data
  Data             [containingData]       * <-- Containment           --> *   [containedData]          Data
	System           [system]               1 <-- DataStoreHosting      --> *   [datastores]             DataStore
  // Vulnerabilities on objects
  Object           [object]               1 <-- ObjectVulnerability   --> *   [vulnerabilities]        VulnerabilityExtensionPoint //We need to implement how vulnerabilities will affect Objects
  // Access Control happens below
  Identity         [identities]           * <-- IdentityCredentials   --> *   [credentials]            Credentials
  // First on system level
  Identity         [highPrivIdentities]   * <-- HighAccessPrivileges  --> *   [highPrivManagedSystems] System
  Identity         [lowPrivIdentities]    * <-- LowAccessPrivileges   --> *   [lowPrivManagedSystems]  System
  // Then, Access Control on application level
  // Bad idea: have two types of identities, the specific one (associations are needed) and the "god mode" one (that does not need to be explicitly connected, you just get all the privs.) This is a problem with AD.
  Identity         [executionPrivileges]  * <-- ExecutionPrivileges   --> * [privilegedApplication]    Application
  Identity         [userIds]              * <-- UserAssignedIdentities--> * [users]                     User
      user info: "Every application executes on a system with privileges of a specified identity on the system."
  Identity         [highPrivAssignedIds]  * <-- HighApplicationPrivileges --> * [highPrivilegeApplications] Application
  Identity         [lowPrivAssignedIds]   * <-- LowApplicationPrivileges  --> * [lowPrivilegeApplications]  Application
  // Finally, Access control on data
  Identity         [accessingIds]         *   <-- ReadPrivileges      --> *   [accessPrivDatastore]    DataStore
  Identity         [readingIds]           *   <-- ReadPrivileges      --> *   [readPrivData]           Data
  Identity         [writingIds]           *   <-- WritePrivileges     --> *   [writePrivData]          Data
  Identity         [deletingIds]          *   <-- DeletePrivileges    --> *   [deletePrivData]         Data
}
