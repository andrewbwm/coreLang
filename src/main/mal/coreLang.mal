#id: "org.mal-lang.coreLang"
#version: "0.0.1"

include "coreVulnerability.mal"
include "VulnerabilityManual.mal"
include "VulnerabilityAutomatic.mal"

category System {

    abstract asset Object
      developer info: "An object is the simplest form of an asset that can be compromised by a vulnerability."
    {
      //& specificAccess

      //& fullAccess

      | useVulnerability
        ->  vulnerabilities.incoming
    }

    asset System extends Object 
      developer info: "A system specifies the hardware on which applications can run. The attacker can DoS everything that is running on it and access (using physical control) on the OS after effort."
    {
      | connect
        user info: "The attacker can connect to the instance, e.g., through a shell, but has not yet authenticated."
        ->  fullAccess,
            specificAccess

      | allPrivilegeAuthenticate @hidden
        ->  fullAccess // This will provide access on all privileges connected with the system

      | individualPrivilegeAuthenticate @hidden
        ->  specificAccess

      & fullAccess {C,I,A}
        ->  sysExecutedApps.access,
            highPrivSysIds.assume,
            lowPrivSysIds.assume,
            sysData.access

      & specificAccess
        ->  sysExecutedApps.localConnect // I do not know what more we need here...

      | physicalAccess
        user info: "Attacker has physical access on the location where the system is physically deployed."
        ->  denialOfService,
            connect

      | denialOfService {A}
        ->  sysExecutedApps.deny
    }

    asset Application extends Object
      developer info: "An application specifies pretty much everything that is executed or can execute other applications."
    {
      | localConnect
        user info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally (on the same host i.e. using loopback) interact with the application."
        ->  localAccess,
            extensionPoint.incoming, // Connection to all possible vulnerabilities that might be connected to the Application
            appExecutedApps.localConnect // But also achieve localConnect on all child applications (this is something that needs to be reviewed again at a later stage)

      | networkConnect
        user info: "An attacker can connect to any network exposed application."
        ->  localAccess,
            extensionPoint.incoming // Connection to all possible vulnerabilities that might be connected to the Application

      | accessNetwork // This should be renamed to be more clear.
        user info: "An attacker is also possible to access the network(s) and connections to which this application is connected to."
        ->  networks.access,
            appConnections.applications.networkConnect
      
      | networkRequestConnect
        user info: "The attacker has successfully sent a request to the application."
        -> networkAccess

      | networkRespondConnect [Exponential(0.001)]
        user info: "An attacker may be able to respond to requests submitted by an application."

      | authenticate
        user info: "The attacker is able to authenticate with the appropriate credentials."
        ->  localAccess,
            networkAccess

      & localAccess @hidden
        ->  access

      & networkAccess @hidden
        ->  access

      | access {C,I,A}
        user info: "Legitimate access, as user or as administrator."
        ->  read,
            modify,
            deny,
            // shellInstance.connect
            appExecutedApps.access, // Gain access on all applications executed by this (host) application
            containedData.access,    // and access on all the contained data
            accessNetwork   // and access the network(s) on which the app is connected

      | codeExecution
        user info: "Vulnerabilities in the application could allow an attacker to inject code into the service process, thus assuming the service's privileges on the hosting instance. An attacker could under these circumstances influence other applications or the underlying operating system itself."
        developer info: "This attack steps specifically models the type of code injections which result in arbitrary code executions (e.g., buffer overflows), where the attacker can redirect the flow of execution, for example, by modifying program counter/instruction pointer of the host. (See CWE-94 on code injection <https://cwe.mitre.org/data/definitions/94.html> and, for example, CAPEC-100 on overflowing buffers <https://capec.mitre.org/data/definitions/100.html>)"
        ->  access,
            // nonShellInstance.connect,
            executionPrivIds.assume

      | read {C}
        user info: "The attacker can read some or all of this service's code and data."
        developer info: "We don't model the services data, as we do not expect that information will be available to the parser. We also don't differentiate between service administrators and service users (e.g., mail service admins and users), as we have no information about the services."

      | modify {I}
        user info: "The attacker can modify some or all of this service's data."

      | deny {A}
        user info: "The attacker can deny some or all functionality and data pertaining to this service."

    }
}

category Communication {

    asset Data {
        & access
          ->  read,
              write,
              delete

        | read {C}
          user info: "The attacker can read the data."
          ->  containedData.read

        | write {I}
          user info: "The attacker can write to the location of the data, effectively deleting it."
          ->  containedData.write,
              delete

        | delete {I,A}
          user info: "The attacker can delete the data."
          ->  containedData.delete
    }
}

category IAM {

    asset Identity 
    {
        | assume {C,I,A}
          developer info: "After authentication or compromise of an account/identity, assume its privileges. This is both legitimate and illegitimate access!"
          ->  lowPrivManagedSystems.individualPrivilegeAuthenticate,
              highPrivManagedSystems.allPrivilegeAuthenticate,
              execPrivApps.access,
              highPrivApps.access,
              lowPrivApps.localConnect,
              readPrivData.read,
              writePrivData.write,
              deletePrivData.delete
    }

    asset Credentials
    {
      | use {C}
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  identities.assume

      | attemptAccess
        user info: "The attacker is attempting to access the credentials."
        -> credentialTheft

      | credentialTheft [Exponential(0.001)]
        user info: "The attacker is able to steal the credentials."
        -> identities.assume
    }

    asset PhysicalZone
      developer info: "A physical zone is the location where systems are physically deployed."
    {
      | gainPhysicalAccess
        ->  systems.connect,
            systems.physicalAccess
    }
}

category User {

    asset User 
    {
        | compromise {C}
          ->  userIds.assume
    }
}

category Networking {
    // If you have access to a network zone, you shall be able to connect (not log in) to any other service on the same network. (nmap scan) (Joar)
    // If you have managed to log in to and use a proxy, transparent or not, you shall be able to access any service protected by that proxy. (Joar)

    asset Network
      developer info: "A network zone is a set of network accessible applications."
    {

      let allowedNetworks =  (netConnections.routerFirewalls.connectionRules.networks /\ netConnections.networks) \/ (outgoingNetConnections.routerFirewalls.connectionRules.inNetworks /\ outgoingNetConnections.inNetworks)
      let allowedApplications = (netConnections.routerFirewalls.connectionRules.applications /\ netConnections.applications) \/ (outgoingNetConnections.routerFirewalls.connectionRules.applications /\ outgoingNetConnections.applications)
      let allNetConnections = netConnections \/ ingoingNetConnections \/ outgoingNetConnections

      // Physical access atack vector
      // iLOs are also reachable from here
      | physicalAccess {A}
        developer info: "Attacker has physical access on the network. This means he can cut wires/fibers and also connect using iLOs."
        ->  denialOfService

      | access
        user info: "Access provides connect to all reachable applications."
        ->  applications.networkConnect,
            //netConnections.networks.access // This has the same effect as the line below! (or so I think, update: I was thinking wrong!)
            //netConnections.routerFirewalls.forwarding, // This was used initialy but it gave access everywhere so it was wrong.
            networkForwarding,
            denialOfService

      | networkForwarding
        developer info: "By using the allowed connections, forwarding from one network to another can happen."
          ->  allowedNetworks().access,
              allowedApplications().networkConnect

      | denialOfService {A}
        user info: "If a DoS is performed it affects, the applications communicatiing over the network as well as the connected application."
        ->  allNetConnections().denialOfService,
            applications.deny
    }

    asset RoutingFirewall extends System 
      developer info: "A routing firewall specifies a router with firewall capabilities that connects many networks."
    {
      
      | denialOfService {A}
        // This should cascade the DoS attack on the connected networks and connected connections.
        ->  connectionRules.denialOfService

      & fullAccess {I, A}
        developer info: "If full access is achieved on RoutingFirewall then it is 0wned and all connections can be allowed!"
        +>  (connectionRules.networks \/ connectionRules.outNetworks \/ connectionRules.inNetworks).access,
            connectionRules.applications.networkConnect

    }

    asset Connection{

      | intercept {C} // Maybe this is not the correct name
        ->  data.access

      | transmitResponse

      | transmit

      | denialOfService {A}
    }

    abstract asset Proxy extends Object {
    }

}

associations {
  System           [hostSystem]        0..1 <-- SysExecution          --> *   [sysExecutedApps]        Application
      developer info: "System is the hardware on which Applications are running. The host system is not mandatory to be specified but if it is, it adds on the model!"
  Application      [hostApp]           0..1 <-- AppExecution          --> *   [appExecutedApps]        Application
      developer info: "Application 1 runs application 2 runs application 3! (Where application 1 can be an OS, application 2 is a VM and application 3 is app running on the VM."
 
  // ### Networking associations
  PhysicalZone     [physicalZone]         * <-- ZoneInclusion         --> *   [systems]                System
      developer info: "Access on PhysicalZone will give physicalAccess on the deployed Systems but access on a System does not always provide access to the physical zone (e.g. iLOs)."

  RoutingFirewall  [routerFirewalls]      * <-- ConnectionRule        --> *   [connectionRules]        Connection
      developer info: "A routing firewall has routing or firewall rules specified by connections between networks or applications respectively."
  Network          [networks]             * <-- NetworkExposure       --> *   [applications]           Application
      developer info: "An application can communicate / be exposed on a network.  A network zone is a set of network accessible applications."
  Application      [applications]         * <-- ApplicationConnection --> *   [appConnections]         Connection
      developer info: "But also, an application can communicate over one or more (mesh type) bidirectional connections."
  Network          [networks]             * <-- NetworkConnection     --> *   [netConnections]         Connection
      developer info: "Two or more networks can also be inter-connected via a bidirectional connection."
  Network          [outNetworks]          * <-- OutNetworkConnection --> *    [outgoingNetConnections] Connection
      developer info: "Two or more networks can also be inter-connected via a uni-directional connection."
  Network          [inNetworks]           * <-- InNetworkConnection  --> *    [ingoingNetConnections]   Connection
      developer info: "Two or more networks can also be inter-connected via a uni-directional connection."
  Connection       [connection]        0..1 <-- DataInTransit         --> *   [data]                   Data 
      developer info: "And a connection can have data in transit."
  //Network          [networks]             * <-- NetworkExposure       --> *   [systems]                System  // Systems should be connected to Physical Zones and not to networks. This assumption should also be tested! 
 
  // ### Data related associations
  Data             [containingData]       * <-- Containment           --> *   [containedData]          Data
      user info: "Data can be contained inside other data."
  Data             [containedData]        * <-- AppContainment        --> *   [containingApp]          Application
      developer info: "An application should be able to contain some data."
  System           [system]            0..1 <-- DataHosting           --> *   [sysData]                Data
      user info: "A system can host data."
  
  // ### Access Control happens below
  Identity         [identities]           * <-- IdentityCredentials   --> *   [credentials]            Credentials
  Identity         [userIds]              * <-- UserAssignedIdentities--> *   [users]                  User
  // First on system level
  Identity         [highPrivSysIds]       * <-- HighAccessPrivileges  --> *   [highPrivManagedSystems] System
      user info: "High access privileges on a System result in the compromise of all the privileges assigned to that system."
  Identity         [lowPrivSysIds]        * <-- LowAccessPrivileges   --> *   [lowPrivManagedSystems]  System
      user info: "Low access privileges on a System provide individual identity access on the system."
  // Then, Access Control on application level
  // Bad idea: have two types of identities, the specific one (associations are needed) and the "god mode" one (that does not need to be explicitly connected, you just get all the privs.) This is a problem with AD.
  Identity         [executionPrivIds]     * <-- ExecutionPrivileges   --> *   [execPrivApps]           Application
      user info: "Every application executes on a system with privileges of a specified identity on the system. If the application is compromised then the privileges should be compromised."
  Identity         [highPrivAppIds]       * <-- HighApplicationPrivileges --> * [highPrivApps]         Application
      user info: "High application privileges on an Application result in the compromise of all the child applications."
  Identity         [lowPrivAppIds]        * <-- LowApplicationPrivileges  --> * [lowPrivApps]          Application
      user info: "Low application privileges on an Application allow only the local interaction with the application."
  // Finally, Access control on data
  Identity         [readingIds]           *   <-- ReadPrivileges      --> *   [readPrivData]           Data
  Identity         [writingIds]           *   <-- WritePrivileges     --> *   [writePrivData]          Data
  Identity         [deletingIds]          *   <-- DeletePrivileges    --> *   [deletePrivData]         Data
}
